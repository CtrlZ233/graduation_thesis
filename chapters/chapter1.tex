%%==================================================
%% chapter01.tex for BIT Master Thesis
%% modified by yang yating
%% version: 0.1
%% last update: Dec 25th, 2016
%%==================================================
\chapter{绪论}
\label{chap:intro}
\section{课题研究的背景和意义}

随着科技的发展，微内核广泛应用于工控系统、嵌入式系统等领域。相比于宏内核，微内核将内存管理、设备驱动、文件系统等与核心功能分离，运行在用户空间，这种隔离机制使得单个服务的故障不会直接影响到内核和其他服务，从而提升了系统的整体稳定性\cite{Thallapally2024}；微内核通过精简核心功能，减少攻击面，从而提升内核安全性；此外，模块化的设计使得系统更易于维护和升级。在微内核系统中，应用程序通过进程间通信(IPC) 而非系统调用来请求服务，这或许能够满足早期性能不敏感的软件需求，然而在对软件性能有着更高要求的今天，频繁IPC造成的特权级切换将产生巨大开销，成为系统的性能瓶颈\cite{liedtke1996toward}。

30 年前 Liedtke 提出的L4 \cite{liedtke1993improving} 重新设计了微内核系统，通过组合系统调用、快速路径、消息寄存器等优化手段，从硬件层到软件层对IPC进行了系统性优化，证明了微内核的IPC 也可以很快，之后以seL4 \cite{klein2009sel4} 为代表的现代微内核的 IPC 框架也基本延续了 L4 的设计理念，以同步 IPC作为主要的通信方式。然而同步IPC迫使单线程中上下文无关的请求以顺序的形式执行，系统只能通过多线程实现并发，而为了更好地利用硬件资源，现代微内核大多引入异步的通知机制来简化并发程序设计，提升多核的利用率，这违反了微内核的最小化设计原则，增加了内核的复杂性。

而随着软件复杂性的提升，用户希望系统级软件如数据库管理系统、网络服务器等能够快速处理大量系统调用和IPC\cite{Caruso2021}，而微内核将操作系统的大部分服务（如网络协议栈、文件系统等）移到用户态，从而使得IPC数量和频率激增，特权级切换成为性能瓶颈。此外，新出现的硬件漏洞如Meltdown\cite{lipp2020meltdown}和Spectre\cite{kocher2020spectre} 漏洞促使内核使用 KPTI补丁\cite{kernel_pti}来分离用户程序和内核的页表，进一步增加了陷入内核的开销。最后，现代微内核的外设驱动往往存在于用户态，外设中断被转化为异步通知，需要用户态驱动主动陷入内核来进行接收，这在一定程度上成为了外设驱动的性能瓶颈\cite{blackham2012improving}。综上所述，由IPC和通知机制引起的特权级切换已经成为制约系统性能的主要因素。

本文提出ReL4，一个用Rust编写的高性能异步微内核，它将同步IPC从内核中移除，基于用户态中断技术设计了无需陷入内核的U-notification机制，在兼容capability机制的基础上改造微内核的通知机制，并利用改造后的U-notification和异步化编程设计和实现了一套绕过内核的异步IPC和异步系统调用框架。ReL4在设计理念上将内核最小化原则贯彻得更加彻底，并通过软硬件协同的方式进一步提升微内核的IPC性能，为下一代微内核的发展指出一个可能的方向。

\section{国内外研究现状及发展趋势}
%\label{sec:***} 可标注label

\subsection{微内核IPC的发展现状}
%\label{sec:features}

现代微内核的大部分IPC优化始于Liedtke提出的L4，由于之前的微内核IPC存在性能瓶颈，L4从硬件优化、系统架构、软件接口的各个方面对IPC进行了重新设计。其中的优化角度可以简单划分为内核路径优化和上下文切换优化。

对于内核路径优化，L4通过物理消息寄存器来传递短消息，从而避免了内存拷贝，然而随着访存速度的加快，消息寄存器的零拷贝优化带来的收益逐渐减弱，使用物理寄存器导致的平台依赖和编译器优化失效反而限制了系统的性能\cite{heiser2016l4}，因此物理的消息寄存器逐渐被现代微内核以虚拟消息寄存器代替；此外，L4使用临时映射的形式来进行长消息的传递，避免多余的内存拷贝，但却在内核中引入了缺页异常的可能性，增加了内核行为的复杂性\cite{heiser2016l4}，现代微内核一般放弃了这个优化；针对常用且普遍的IPC场景，L4设计了专门的快速路径，避免了复杂繁琐的参数解析和任务调度，然而该优化手段对消息长度、任务优先级有着严格的限制，也无法对多CPU核心进行支持。

对于特权级的切换优化，L4使用的物理消息寄存器在一定程度上减少了上下文切换的开销，但其副作用超过了优化收益导致其被虚拟消息寄存器代替\cite{heiser2016l4}；同时L4敏锐地观察到大部分IPC通信遵循C/S模型，因此通过组合系统调用的形式，将Send + Reply 组合为 Call，将Reply + Recv 组合成ReplyRecv，从而减少了特权级切换的频率，该优化至今作为现代微内核的重要优化手段，但仍然无法避免特权级的切换；此外，L4通过通过ASID机制，在快表项中维护地址空间标识符，减少快表冲刷的频率，缓解了快表污染的问题，然而依然无法避免特权级切换带来的快表污染和缓存失效。

除此之外，L4仅支持同步IPC，对于多核架构，同步IPC会导致服务调用被顺序执行，导致资源浪费。其次，同步IPC强制用户态以多线程的形式处理并发请求，导致了线程同步的复杂性。现代微内核在内核中引入异步通知机制，简化并发编程模型，却使得内核功能冗余，违反了内核最小化原则。

总而言之，现代微内核在单核环境下的IPC内核路径上的优化已经较为完善，在最理想的情况下仅需要两次特权级切换，然而对多核环境下，由于需要核间中断，IPC无法进入快速路径，导致多核下的IPC内核路径依旧冗长。而现代微内核在特权级切换的优化方面仍然停留缓解的层面上，导致特权级切换会成为IPC的性能瓶颈。


\subsection{特权级切换}
特权级的开销主要分为两部分，一部分是直接开销，包括了保存上下文带来的额外指令开销，另一部分是间接开销，地址空间切换所引起的缓存污染会导致CPU执行效率降低。表\ref{tab:seL4_call_cost}展示了在FPGA上部署的seL4一次Call IPC操作所带来的开销占比，大部分的开销都花费在地址空间切换上，其次是上下文的切换和fast-path检查，如果fast-path检查失败，将会进入slow-path进行更加冗长的解码和调度流程，进一步降低IPC性能。
\begin{table}
    \centering
    \begin{tabular}{|c|c|}
        \hline 
        操作 & 占比 \\
        \hline
        保存和恢复上下文 & 14.5\% \\
        \hline
        地址空间切换 & 59.4\% \\
        \hline
        fast - path检查 & 20.1\% \\
        \hline
        消息拷贝 & 1.5\% \\
        \hline
        其他 & 4.5\% \\
        \hline
    \end{tabular}
    \caption{seL4一次IPC中各操作的开销占比}
    \label{tab:seL4_call_cost}
\end{table}
    

本文聚焦现代微内核架构设计中的特权级切换开销，旨在设计一种新型的IPC架构，减少甚至消除IPC和系统调用中的特权级切换，先前已经有大量的工作从软硬件的角度致力于减少特权级切换开销。

从硬件出发的角度出发，大多数工作通过设计特殊的硬件或者特殊的指令来绕过内核实现IPC。如SkyBridge\cite{mi2019skybridge}允许进程在IPC中直接切换到目标进程的虚拟地址空间并调用目标函数，它通过精心设计一个Root Kernel提供虚拟化的功能，通过VMFUNC地址空间的直接切换，并通过其他一系列软件手段来保证安全性，但这种方案仅适用于虚拟化环境中。XPC\cite{du2019xpc}则直接使用硬件来提供一个无需经过内核的同步功能调用，并提供一种新的空间映射机制用于调用者与被调用者之间的零拷贝消息传递，然而该方案没有相应的硬件标准，也没有一款通用的处理器对其进行支持。这些方法都基于特殊的环境或者没有标准化的硬件来实现，适用范围有限。

从软件出发的角度出发，相关工作主要分为两类：第一类方法通过将用户态和内核态的功能扁平化来减少内核与用户态的切换开销，如unikernel\cite{kuo2020linux, olivier2019binary, yu2017web}将所有用户态代码都映射到内核态执行，Userspace Bypass\cite{zhou2023userspace} 通过动态二进制分析将两个系统调用之间的用户态代码移入内核态执行，从而减少陷入内核的次数，kernel bypass\cite{jeong2014mtcp, yang2017spdk}则通过将硬件驱动（传统内核的功能）移入用户态，从而减少上下文的切换。这些方法要么需要特殊的硬件支持，要么难以与微内核的设计理念兼容。第二类方法则是允许用户空间对多个系统调用请求排队，并通过一次提交将他们注册给内核，如FlexSC\cite{soares2010flexsc}通过在用户态设计一个用户态线程的运行时，将用户态线程发起的系统调用自动收集，然后陷入内核态进行批量执行。该方法虽然可以有效的减少陷入内核的次数，但如何设置提交的时机难以把握，过短的提交间隔将导致切换次数增加，过长的提交间隔则会导致CPU空转。

虽然现有工作难以广泛且有效地应用到微内核中，但他们的思路值得借鉴，他们的缺陷驱使研究者去寻求更好的方案。在硬件方面，一种新型的硬件技术方案——用户态中断\cite{nassif2022sapphire, RISCVPrivileged2020}逐渐被各个硬件平台（x86，RISC-V）采纳，它通过在CPU中新增中断代理机制和用户态中断的状态寄存器，当中断代理机制检测到状态寄存器发生变化时，会将中断以硬件转发的形式传递给用户态程序，从而绕过内核。该硬件方案已经在Sapphire Rapids x86处理器上和RISCV的N扩展中有了一定的支持，适用范围更加广泛。而在软件方面，异步被广泛用于请求合并和开销均摊，传统类Unix系统提供的类似select IO多路复用接口相对简陋，迫使用户态代码采用事件分发的编程范式来处理异步事件，代码相对复杂，可读性较弱。而新兴的Rust\cite{levy2015ownership, balasubramanian2017system}语言对异步有着良好的支持，其零成本抽象的设计也让它作为系统编程语言有着强大的竞争力。使用Rust进行内核和用户态基础库的开发，可以更好地对异步接口进行抽象，改善接口的易用性和代码的可读性。

\begin{table}
    \centering
    \resizebox{\textwidth}{!}{ % \textwidth 表示文本宽度，! 表示保持宽高比
    \begin{tabular}{|c|c|c|c|}
        \hline
        \textbf{优化方法} & \textbf{详细分类} & \textbf{实例} & \textbf{缺点} \\
        \hline
        \multirow{3}{*}{减少内核路径} & 临时地址映射 & [3] & \multirow{3}{*}{上下文切换开销已经成为性能瓶颈} \\
        \cline{2-3}
         & 快速路径 & \multirow{2}{*}{[3, 4, 24, 25, 26]} & \\
        \cline{2-2}
         & 消息寄存器 & & \\
        \hline
        \multirow{5}{*}{减少上下文切换开销} & 消息寄存器 & \multirow{2}{*}{[3, 4, 24, 25, 26]} & \multirow{3}{*}{无法从根本上消除切换开销} \\
        \cline{2-2} \cline{4-4}
         & 组合系统调用 & & \\
        \cline{2-3}
         & ASID机制 & [4] & \\
        \cline{2-4}
         & 统一地址空间 & [13, 14, 15, 16, 17, 18] & \multirow{2}{*}{与微内核设计理念相悖，无法有效地实施到微内核中} \\
        \cline{2-3}
         & 批量系统调用 & [19] & \\
        \hline
        \multirow{3}{*}{硬件优化} & 虚拟化指令 & [11] & 仅适用于虚拟化环境 \\
        \cline{2-4}
         & \multirow{2}{*}{直接硬件辅助} & [12] & 没有硬件标准，没有通用硬件的支持 \\
        \cline{3-4}
         & & 用户态中断 & --- \\
        \hline
        \end{tabular}
    }
    \caption{国内外研究现状汇总}
    \label{tab:optimization_methods}
\end{table}

\section{主要研究内容}
本文以免费开源的seL4的IPC系统主要研究对象，介绍了seL4中IPC的设计细节以及相关设计缺陷，针对seL4的相关缺陷，基于用户态中断，给出了高性能异步微内核的整体设计方案，包含了无需内核转发的通知机制U-notification、异步IPC与异步系统调用，并基于Rust语言在RISC-V平台实现了ReL4原型系统。在FPGA上将U-notification、异步IPC 和异步系统调用分别与seL4进行了对比测试，并评估了ReL4在真实的TCP Server Benchmark上的性能表现。论文内容结构安排如下：

第1章，绪论部分，阐述了本课题的研究背景及意义，国内外研究现状和发展趋势，最后概述了本课题的研究内容和对内容的组织结构。

第2章，介绍了seL4系统的发展历史和主要特征，并对seL4中的基本概念以及IPC设计进行了系统性阐述。

第3章，系统设计部分。首先介绍了ReL4与seL4的关系，ReL4的特点以及设计目标，然后介绍了ReL4如何对系统中各个部分的通知机制进行支持和优化，最后介绍了用于保证兼容性和提升易用性的异步运行时的组成部分和设计思路。

第4章，系统实现部分。主要介绍了新增的系统调用，以及基于U-notification的异步运行时如何实现异步IPC和异步系统调用。

第5章，兼容性讨论。主要讨论了ReL4在通知机制与IPC机制中对seL4的兼容程度。

第6章，系统评估部分。首先介绍了ReL4的测试方案，然后针对ReL4的各个机制进行了性能评估和分析，最后测试了ReL4在真实的TCP Server Benchmark上的性能表现。

第7章，总结与展望，对本次设计和论文工作进行了总结，并提出了进一步的研究方向与对未来工作的展望。